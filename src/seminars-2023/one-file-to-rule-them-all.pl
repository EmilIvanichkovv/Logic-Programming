% На пролог променливите не се декларират предварително.  Дали
% дадена дума е променлива или символ за индивидна константа,
% пролог разпознава по следния начин: променливите започват с
% главна буква, а константите – с малка.  Например X, Y0,
% Резултат са променливи, а x, n5 и софия са константи.

% Забележка: в литературата за пролог такива константи се наричат
% атоми.  Тук обаче няма да ги наричаме атоми, за да не би някой
% да си помисли, че има нещо общо между атом и атомарна формула.

% Клауза от вида
%    p(X) :- q(X,Y), r(Z).
% отговаря на следната логическа формула:
%    q(x,y) & r(z) ⇒ p(z)
% Но понеже пролог ще приеме, че тази клауза е тъждествено вярна,
% то всъщност имаме следната формула:
%    ∀x∀y(q(x,y) & r(z) ⇒ p(z))

% Пролог „приема“, че сме му казали истината, цялата истина и
% само истината.  Затова ако кажем например следните две клаузи
%    p(X) :- q(X).
%    p(X) :- r(X).
% и няма други клаузи, в които се говори кога е верен предикатът
% p, то пролог ще реши, че е вярно
%    ∀x(q(x) ∨ r(x) ⇔ p(x))
% въпреки че ние сме му казали не това, а само
%    ∀x(q(x) ∨ r(x) ⇒ p(x))

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ФУНКЦИОНАЛЕН СТИЛ НА ПРОГРАМИРАНЕ НА ПРОЛОГ
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% При фунционалните езици дефинираме функция f, за която
%       f(x,y)=z, където y е някакъв израз.
% Вместо това на пролог ще дефинираме предикат p, такъв че
%       p(x,y,z) е истина тогава и само тогава, когато f(x,y)=z

% За момента да считаме (макар че не е точно така), че на пролог
% има един тип данни: термове, т.е. изрази.  Например = е
% равенство между изрази, а не равенство между числа.  Затова

%% ?- 1+2=3.
%% false.

%% ?- 1+2=1+X.
%% X = 2.

% Едно уникално и забележително от теоретична гледна точка
% свойство на пролог е това, че дори да го лишим от абсолютно
% всички вградени предикати, езикът продължава да бъде
% използваем.  Например естествените числа може да ги представим
% по следния начин:
%
%   - нулата ще представяме посредством символа 0 (разбира се тук
%     0 е символ за индивидна константа, а не число)
%   - числото n+1 ще представяме с терма s(n).
%
% Например числото 3 ще представяме посредством терма s(s(s(0)).
%
% След като сме избрали представяне на естествените числа
% посредством термове, не е проблем да дефинираме предикати за
% различните аритметични операции.  Например събирането може да
% дефинираме така:

% сбор(N,M,K) - К е сбор на естествените числа N и M

сбор(0,X,X).
сбор(s(X),Y,s(Z)) :- сбор(X,Y,Z).

%% ?- сбор(s(s(0)), s(s(s(s(0)))), Сбор).
%% Сбор = s(s(s(s(s(s(0)))))).

% Да дефинираме предикат за символно диференциране.  Засега да
% считаме, че типът данни, с които работи пролог, е типът „терм“.
% Разбира се аритметичните изрази са термове от специален вид,
% така че можем да работим с тях директно без да се налага да
% дефинираме собствени типове.

% dx(F,DF) - DF е производна на F по x (F е израз на реална
%            функция)

dx(0, 0).
dx(1, 0).
dx(2, 0).
dx(3, 0).
dx(4, 0).

% dx(X, 1) би казало, че производната на всяка функция е 1.
% Имаме нужда от нещо, което за нас е променлива, но за пролог не
% е.  Затова използваме x вместо X
dx(x, 1).
dx(y, 0).
dx(z, 0).
dx(t, 0).
dx(u, 0).
dx(v, 0).
dx(w, 0).
dx(-F, -DF) :- dx(F,DF).
dx(F+G, DF+DG) :- dx(F, DF), dx(G,DG).
dx(F-G, DF-DG) :- dx(F, DF), dx(G,DG).
dx(F*G, DF*G+DG*F) :- dx(F, DF), dx(G,DG).
dx(F/G, (DF*G-DG*F)/(G*G)) :- dx(F, DF), dx(G,DG).

dx(ln(F), DF/F) :- dx(F, DF).
dx(sin(F), cos(F)*DF) :- dx(F,DF).
dx(cos(F), -sin(F)*DF) :- dx(F,DF).

% Да пробваме как работи така дефинираният предикат:

%% ?- dx(x+y+z+1+t+0, F).
%% F = 1+0+0+0+0+0.

%% ?- dx(x+cos(x+y)*z-1/t+0, F).
%% F = 1+(-sin(x+y)*(1+0)*z+0*cos(x+y))-(0*t-0*1)/(t*t)+0.

% Получихме верни отговори, но изразите са сложни и очевидно има
% начин да се опростят.  Да дефинираме предикат за опростяване на
% израз.

% Най-напред да даучим пролог на някои формули за опростяване на
% изрази.

формула(0+F, F).
формула(F+0, F).
формула(0-F, -F).
формула(F-0, F).
формула(0*_F, 0).
формула(_F*0, 0).
формула(0/_F, 0).
формула(1*F, F).
формула(F*1, F).
формула(F/1, F).
формула(sin(0), 0).
формула(F+(G+H), (F+G)+H).
формула(F*(G*H), (F*G)*H).
формула(F*2, 2*F).
формула(F*3, 3*F).
формула(F*4, 4*F).
формула(X+(-Y), X-Y).
формула((-X)-Y, -(X+Y)).
формула((-X)*Y, -(X*Y)).
формула(X*(-Y), -(X*Y)).
формула((-X)/Y, -(X/Y)).
формула(X/(-Y), -(X/Y)).
формула(-(-X), X).

% Предикатът редукция(F, G) опростява еднокретно израза F,
% прилагайки някоя от формулите за опростяване. Резултатът е G.

% Tук прилагаме предиката формула към целия израз F.
% Например (x+y)+0 ще се опрости до x+y.
редукция(F, F1) :- формула(F, F1).

% По-долу прилагаме предиката формула в дълбочина.  Например
% (x+0)+y ще се опрости до x+y.  По една клауза за всяка унарна
% операция и по две клаузи за всяка бинарна операция.

редукция(F+G, F1+G) :- редукция(F, F1).
редукция(G+F, G+F1) :- редукция(F, F1).
редукция(F-G, F1-G) :- редукция(F, F1).
редукция(G-F, G-F1) :- редукция(F, F1).
редукция(F*G, F1*G) :- редукция(F, F1).
редукция(G*F, G*F1) :- редукция(F, F1).
редукция(F/G, F1/G) :- редукция(F, F1).
редукция(G/F, G/F1) :- редукция(F, F1).
редукция(-F, -F1) :- редукция(F, F1).
редукция(ln(F), ln(F1)) :- редукция(F, F1).
редукция(sin(F), sin(F1)) :- редукция(F, F1).
редукция(cos(F), cos(F1)) :- редукция(F, F1).

% Да забележим, че чрез предиката редукция дефинираме многозначна
% функция, защото за един израз може да има много начини, по
% които той може да бъде опростен.  Например изразът x+0+y+0+x+0
% може да бъде опростен едностъпково по три различни начина:

%% ?- редукция(x+0+y+0+x+0, F).
%% F = x+0+y+0+x ;
%% F = x+0+y+x+0 ;
%% F = x+y+0+x+0 ;
%% false.

% Една многозначна функция може да има и нула на брой стойности.
% Тъй като нямаме формула, която да казва, че 1+1 е равно на 2,
% то изразът 1+1 няма да може да се опрости:

%% ?- редукция(1+1, F).
%% false.

% „Условен оператор“ на пролог:

% ( F -> G ; H) :- if F then G else H.

% Този „предикат“ може да се използва само когато програмираме
% функционално.  Когато програмираме логически, е възможно
% стойността на F все още да не бъде известна и затова условният
% оператор няма да работи коректно.  Един лош дефект на пролог е
% това, че компилаторът няма да ни предупреди, че се е случила
% грешка (въпреки че при правилно направен компилатор, това е
% възможно).  Вместо да се получи съобщение за грешка, просто
% програмата ще работи неправилно.  Този дефект се дължи на
% старостта на езика и се проявява не само тук, но и в други
% ситуации.

% Прилагаме едностъпково_опростяване докато може.
опростяване(F, G) :-
    (  редукция(F, F1)
    -> опростяване(F1, G)
    ;  G = F ).

% Този предикат прави едностъпкови опростявания на израза докато
% може, а не само веднъж.  Например в израза x+0+y+0+x+0 ще махне
% не една, а всички нули:

%% ?- опростяване(x+0+y+0+x+0, F).
%% F = x+y+x.

% Да видим как ще се опростят производните, които по-горе
% сметнахме:

%% ?- dx(x+y+z+1+t+0, F), опростяване(F, G).
%% F = 1+0+0+0+0+0,
%% G = 1.

%% ?- dx(x+cos(x+y)*z-1/t+0, F), опростяване(F, G).
%% F = 1+(-sin(x+y)*(1+0)*z+0*cos(x+y))-(0*t-0*1)/(t*t)+0,
%% G = 1-sin(x+y)*z- - 0.

% Опрости се, но може и още.  Не сме казали на компютъра, че
% X-(-Y)=X+Y.  Ако добавим следния ред

%% формула(X-(-Y), X+Y).

% компютърът ще работи така:

%% ?- dx(x+cos(x+y)*z-1/t+0, F), опростяване(F, G).
%% F = 1+(-sin(x+y)*(1+0)*z+0*cos(x+y))-(0*t-0*1)/(t*t)+0,
%% G = 1-sin(x+y)*z.


%%%%%%%%%%%%%%%%%
% СПИСЪЦИ
%%%%%%%%%%%%%%%%%

% Понеже на пролог работим с изрази, то на теория няма нужда от
% списъци.  Може да си мислим, че f(1,f(2,f(3,c))) е списъкът
% [1,2,3], а c е списъкът [].

% В израза f(X,Y) X е първият елемент и се нарича глава на
% списъка; Y е опашката - списък от останалите елементи

% Въпреки че на теория няма нужда от списъци, езикът пролог
% поддържа по-четлив синтаксис:

% вместо f(X,Y) пишем [X|Y]
% вместо f(1,f(2,f(3,c))) пишем [1,2,3]
% вместо c пишем []

% Примери:

%% ?- [A|X] = [1,2,3,4].
%% A = 1,
%% X = [2, 3, 4].

%% ?- [A,B|Y] = [1,2,3,4].
%% A = 1,
%% B = 2,
%% Y = [3, 4].

%% ?- [A,B,C,D|Y] = [1,2,3,4].
%% A = 1,
%% B = 2,
%% C = 3,
%% D = 4,
%% Y = [].

%% ?- [A,B,C,D,E|Y] = [1,2,3,4].
%% false.

% Ще спазвам следната уговорка:

% за списъци: X, Y, Z
% за елементи: A, B, C
% списък от списъци: XX, YY, ZZ

% СТРУКТУРНА ИНДУКЦИЯ (РЕКУРСИЯ) ЗА СПИСЪЦИ:

% разглеждаме два случая: [] и [A|X]

% Да дефинираме със структурна индукция предикат
% четно_позиционирани:

% четно_позиционирани(X, Y) - Y е списък от елементите на четна
%                             позиция в X
%
% Условие: известно е ограничение отгоре за дължината на X или
%          дължината на Y
четно_позиционирани([], []).
четно_позиционирани([_|X], Y) :- нечетно_позиционирани(X, Y).

% нечетно_позиционирани(X, Y) - Y е списък от елементите на
%                               нечетна позиция в X
%
% Условие: известно е ограничение отгоре за дължината на X или
%          дължината на Y
нечетно_позиционирани([], []).
нечетно_позиционирани([A|X], [A|Y]) :- четно_позиционирани(X, Y).

% Няма проблем да използваме тези предикати „функционално“:

%% ?- четно_позиционирани([1,2,3,4,5,6,7], X).
%% X = [2, 4, 6].

%% ?- нечетно_позиционирани([1,2,3,4,5,6,7], X).
%% X = [1, 3, 5, 7].

% Но не бива да си мислим, че сме дефинирали две функции.  Не,
% направили сме друго: обяснили сме на компютъра какво означава
% даден списък да съдържа елементите на четна позиция от друг.  А
% това, че след такова обяснение компютърът може да смята
% функция, е само страничен ефект.  Всъщност компютърът може
% много повече:

%% ?- четно_позиционирани(X, [1,2,3,4]), нечетно_позиционирани(X, [a,b,c,d,e]).
%% X = [a, 1, b, 2, c, 3, d, 4, e].

% Пролог може да работи с непълна информация.  Не е проблем да
% уточним единствено кои са елементите на четна позиция, при
% което другите ще останат неизвестни:

%% ?- четно_позиционирани(X, [1,2,3,4]).
%% X = [_6610, 1, _6622, 2, _6634, 3, _6646, 4] ;
%% X = [_6610, 1, _6622, 2, _6634, 3, _6646, 4, _7320].

% При правилно използване на логическия стил на програмиране имаме две
% гаранции:

% 1. Ако казваме на компютъра верни неща, ще получаваме само верни отговори.

% 2. Ако компютърът каже, че няма (повече) отговори, значи наистина няма.

% По този начин много лесно получаваме частичната коректност на една
% логическа програма.  При другите езици един ред от програмата не може да
% се разглежда изолирано от останалите.  На пролог обаче един ред е едно
% нещо, което казваме на компютъра.  Верността на това нещо не зависи от
% верността на останалите неща.  Затова частичната коректност на програмата
% се получава много лесно.  Например във втория ред от програмата за
% четно_позиционирани сме казали на компютъра следното нещо:

% на пролог:

%    четно_позиционирани([_|X], Y) :- нечетно_позиционирани(X, Y).

% същото, но за хора:

%    Ако списъкът Y се състои от елементите на нечетна позиция в списък X,
%    то тогава списъкът Y се състои от елементите на четна позиция в кой да
%    е списък от вида [_|X].

% Верността на горното не зависи по никакъв начин от верността на останалите
% неща, които сме казали в програмата.  Т.е. при проверка на частичната
% коректност разсъждаваме „локално“ и е много по-лесно да се разсъждава.

% p(X,Y) :- Y се получава като разменим в X елементите на четна позиция с
%           елементите на нечетна позиция.

p(X,Y) :- четно_позиционирани(X,V),   % (1)
          нечетно_позиционирани(X,W), % (2)
          четно_позиционирани(Y,W),   % (3)
          нечетно_позиционирани(Y,V). % (4)

% Ако прочетем горното като математическо твърдение, забелязваме, че то е
% вярно.  Това ни дава частичната коректност на предиката p.

% За да получим пълна коректност, трябва да видим, че са изпълнени условията
% в спецификацията на предикатите, които използваме.  В нашия случай това са
% предикатите четно_позиционирани и нечетно_позиционирани.  Условията в
% тяхната спецификация казват, че поне един от аргументите им трябва да бъде
% с известна дължина.  Да видим кога ще бъдат изпълнени тези условия.

% (1): X или V трябва да бъдат списък с известна дължина.  Но V е
% променлива, която на това място се среща за пръв път, така че няма как да
% бъде с известна дължина.  Значи X трябва да бъде с известна дължина.  След
% изпълнението на (1) променливата V също ще стане с известна дължина.

% (2): Вече знаем, че X трябва да бъде с известна дължина.  Така че в този
% ред условието е изпълнено.  След изпълнението на (2) променливата W също
% става списък с известна дължина.

% (3): Условието е изпълнено, защото W вече е списък с известна дължина.
% След изпълнението на (3) променливата Y също става списък с известна
% дължина (ако дължината на W е n, то дължината на Y е 2n или 2n+1.

% (4): Условието е изпълнено, защото когато дойдем до този ред Y и V са
% списъци с известна дължина.

% Горните разсъждения показват, че за да работи p(X,Y), е достатъчно X да
% бъде списък с известна дължина.  Това е условието за коректност на
% предиката p.

% При следващия въпрос сме спазили това условие за p.  Затова компютърът
% намира верният отговор и правилно отговаря, че втори верен отговор няма:

%% ?- p([1,2,3,4],X).
%% X = [2, 1, 4, 3] ;
%% false.

% Обаче при следващото извикване не сме спазили условието за коректност на p.
% Дори в този случай компютърът няма да ни излъже (защото имаме частична
% коректност), само че след като намери верният отговор, компютърът ще
% продължи да търси други отговори без да може да се сети, че такива няма:

%% ?- p(X,[1,2,3,4]).
%% X = [2, 1, 4, 3] ;
%%   Action (h for help) ? a
%% abort
%% % Execution Aborted


% елемент(A, X) :- А е елемент на списъка X
% Вграден е като member(A, X)
%
% Условие: Известно е ограничение отгоре за дължината на X

% елемент(A, [B|X]) :- A = B ; елемент(A, X).

елемент(A, [A|_]).
елемент(A, [_|X]) :- елемент(A, X).

% Вярно ли е, че 5 е елемент на [1,2,3]?
%% ?- елемент(5, [1,2,3]).
%% false.

% Вярно ли е, че 2 е елемент на [1,2,3]?
%% ?- елемент(2, [1,2,3]).
%% true

% Кои са елементите на [1,2,3]?
%% ?- елемент(B, [1,2,3]).
%% B = 1 ;
%% B = 2 ;
%% B = 3 ;
%% false.

% Кои са всички триелементни списъци, които съдържат а, б и в?
%% ?- X=[_,_,_], елемент(а, X), елемент(б, X), елемент(в, X).
%% X = [а, б, в] ;
%% X = [а, в, б] ;
%% X = [б, а, в] ;
%% X = [в, а, б] ;
%% X = [б, в, а] ;
%% X = [в, б, а] ;
%% false.


% конкат(X, Y, Z) - Z е конкатенация на списъците X и Y
% Вграден е като append(X, Y, Z)
%
% Условие: Известно е ограничение отгоре за дължината на X или дължината
%          на Z

% Правим структурна индукция по първия аргумент.
конкат([], Y, Y).
конкат([A|X], Y, [A|Z]) :- конкат(X, Y, Z).

% Каква е конкатенацията на [] и [a,b,c]?
%% ?- конкат([],[a,b,c],X).
%% X = [a, b, c].

% Каква е конкатенацията на [1,2] и [3,4,5]?
%% ?- конкат([1,2],[3,4,5],X).
%% X = [1, 2, 3, 4, 5].

% Кой списък, конкатениран с [1,2], дава [1,2,3,4,5]?
%% ?- конкат([1,2],X, [1,2,3,4,5]).
%% X = [3, 4, 5].

% Може и така, защото е изпълнено условието за пълна коректност – известен е
% броят на елементите на първия или третия аргумент (в случая на първия):
%% ?- конкат([1,2], X, Y).
%% Y = [1, 2|X].

% Обаче така не може.  Макар пролог вярно да генерира всички възможни
% отговори, те са безброй много, така че програмата най-вероятно ще
% зацикли.
%% ?- конкат(X, [1,2], Y).
%% X = [],
%% Y = [1, 2] ;
%% X = [_2688],
%% Y = [_2688, 1, 2] ;
%% X = [_2688, _3742],
%% Y = [_2688, _3742, 1, 2] ;
%% X = [_2688, _3742, _4796],
%% Y = [_2688, _3742, _4796, 1, 2] ;
%% X = [_2688, _3742, _4796, _5850],
%% Y = [_2688, _3742, _4796, _5850, 1, 2] ;
%% X = [_2688, _3742, _4796, _5850, _6904],
%% Y = [_2688, _3742, _4796, _5850, _6904, 1, 2] ;
%% X = [_2688, _3742, _4796, _5850, _6904, _7958],
%% Y = [_2688, _3742, _4796, _5850, _6904, _7958, 1, 2] ;

% Как списъкът [1,2,3,4] може да се разцепи на два списъка X и Y?
%% ?- конкат(X, Y, [1,2,3,4]).
%% X = [],
%% Y = [1, 2, 3, 4] ;
%% X = [1],
%% Y = [2, 3, 4] ;
%% X = [1, 2],
%% Y = [3, 4] ;
%% X = [1, 2, 3],
%% Y = [4] ;
%% X = [1, 2, 3, 4],
%% Y = [] ;
%% false.

% Алтернативна, по-неефективна, но по-кратка дефиниция на предиката елемент.
% елемент(A, X) :- конкат(_, [A|_], X).

% предпоследен(X, A) - А е предпоследният елемент на списъка X
%
% Условие: известно е ограничение отгоре за дължината на X

предпоследен(X, A) :- конкат(_, [A,_], X).

%% ?- предпоследен([1,2,3,4,5], A).
%% A = 4

% префикс(X, Y) - списъкът X е начало (префикс) на списъка Y
%
% Условие: известно е ограничение отгоре за дължината на X или на Y

префикс(X, Y) :- конкат(X, _, Y).

% Кои са префиксите на [a,b,c]?
%% ?- префикс(X, [a,b,c]).
%% X = [] ;
%% X = [a] ;
%% X = [a, b] ;
%% X = [a, b, c] ;
%% false.

% На кои списъци X е префикс?
%% ?- префикс([1,2,3], X).
%% X = [1, 2, 3|_5620].

% ротация(X, Y) - списъкът Y е ротация на списъка X
%
% Условие: известно е ограничение отгоре за дължината на X

ротация(X, Y) :- конкат(X1, X2, X), конкат(X2, X1, Y).

% Генериране на музикалните ладове
%% ?- ротация([до,ре,ми,фа,сол,ла,си], X).
%% X = [до, ре, ми, фа, сол, ла, си] ;    % йонийски
%% X = [ре, ми, фа, сол, ла, си, до] ;    % дорийски
%% X = [ми, фа, сол, ла, си, до, ре] ;    % фригийски
%% X = [фа, сол, ла, си, до, ре, ми] ;    % лидийски
%% X = [сол, ла, си, до, ре, ми, фа] ;    % миксолидийски
%% X = [ла, си, до, ре, ми, фа, сол] ;    % еолийски
%% X = [си, до, ре, ми, фа, сол, ла] ;    % локрийски
%% X = [до, ре, ми, фа, сол, ла, си] ;    % йонийски
%% false.

% пермутация(X, Y) - списъкът Y е пермутация на списъка X
%
% Условие: известно е ограничение отгоре за дължината на X

% Първи начин: структурна индукция по първия аргумент на предиката.

пермутация([], []).
пермутация([A|X], Z) :- пермутация(X, Y), вмък(A, Y, Z).

% вмък(A, X, Y) - Y може да се получи като вмъкнем A на произволна
%                 позиция в X
%
% Условие: известно е ограничение отгоре за дължината на X или дължината на Y

вмък(A, X, [A|X]).
вмък(A, [B|X], [B|Y]) :- вмък(A, X, Y).

% може и така (по-неефективно и с по-ограничително условие за пълна
% коректност, но по-кратко):
вмък2(A, X, Y) :- конкат(X1, X2, X), конкат(X1, [A|X2], Y).

%% ?- вмък('!', [1,2,3], X).
%% X = [!, 1, 2, 3] ;
%% X = [1, !, 2, 3] ;
%% X = [1, 2, !, 3] ;
%% X = [1, 2, 3, !] ;
%% false.

%% ?- пермутация([a,b,c], X).
%% X = [a, b, c] ;
%% X = [b, a, c] ;
%% X = [b, c, a] ;
%% X = [a, c, b] ;
%% X = [c, a, b] ;
%% X = [c, b, a] ;
%% false.

% Втори начин: структурна индукция по втория аргумент на предиката.

пермутация2([], []).
пермутация2(X , [A|Z]) :- измък(X, A, Y), пермутация2(Y, Z).

% За измък може пак да използваме структурна индукция
% измък([A|Y], A, Y).
% измък([B|X], A, [B|Z]) :- измък(X, A, Z).

% Но не е нужно, защото измък е обратното на вмък, а какво значи вмък вече
% сме обяснили на пролог.

измък(X, A, Y) :- вмък(A, Y, X).

%% ?- измък([1,2,2,3], A, X).
%% A = 1,
%% X = [2, 2, 3] ;
%% A = 2,
%% X = [1, 2, 3] ;
%% A = 2,
%% X = [1, 2, 3] ;
%% A = 3,
%% X = [1, 2, 2] ;
%% false.

%% ?- пермутация2([1,2,3],X).
%% X = [1, 2, 3] ;
%% X = [1, 3, 2] ;
%% X = [2, 1, 3] ;
%% X = [2, 3, 1] ;
%% X = [3, 1, 2] ;
%% X = [3, 2, 1] ;
%% false.

% Условието при предикатите пермутация и пермутация2 беше да е известна
% дължината на първия аргумент.  От математическа гледна точка обаче ако X е
% пермутация на Y, то Y е пермутация на X.  Т.е. не би трябвало да има
% значение дали е известен първия или втория аргумент.  Да направим
% предикат, който може да се използва и в двете посоки.

% равна_дължина(X, Y) - списъците X и Y са с равна дължина.
%
% Условие: известно е ограничение отгоре за дължината на поне един от
%          аргументите

равна_дължина([],[]).
равна_дължина([_|X],[_|Y]) :- равна_дължина(X, Y).

двупосочна_пермутация(X, Y) :- равна_дължина(X, Y),
                               пермутация2(X, Y). % или пермутация(X,Y)

%% ?- двупосочна_пермутация([1,2,3],X).
%% X = [1, 2, 3] ;
%% X = [1, 3, 2] ;
%% X = [2, 1, 3] ;
%% X = [2, 3, 1] ;
%% X = [3, 1, 2] ;
%% X = [3, 2, 1] ;
%% false.

%% ?- двупосочна_пермутация(X,[1,2,3]).
%% X = [1, 2, 3] ;
%% X = [1, 3, 2] ;
%% X = [2, 1, 3] ;
%% X = [3, 1, 2] ;
%% X = [2, 3, 1] ;
%% X = [3, 2, 1] ;
%% false.

%%%%%%%%%%%%%%%%%%%%%%%%%
% ЦЕЛОЧИСЛЕНА АРИТМЕТИКА
%%%%%%%%%%%%%%%%%%%%%%%%%

% Когато използваме суи пролог, за да заредим библиотеката за целочислена
% аритметика, добавяме към програмата следния ред:

:- use_module(library(clpfd)).

% Първоначално пролог е създаден като безтипов език.  Или по-точно като
% език, в който единственият тип данни е „терм“ (също както например на лисп
% и скийм единственият тип данни е „списък“).  С други думи на пролог
% дефинираме ербранова структура, чийто единствен носител е множеството от
% всички термове без променливи.

% Когато се използва библиотеката за целочислена аритметика (както и други
% подобни библиотеки), програмата на пролог вече дефинира не ербранова
% структура, а двусортна структура с два носителя.  Първият носител е
% множеството от термовете без променливи (който го имаме и без тази
% библиотека).  Вторият носител е множеството от целите числа.  С други думи
% вече имаме не един, а два примитивни типа: израз (т.е. терм) и цяло число.

% Въпреки че структурата на програмата става двусортна, пролог е проектиран
% като безтипов език, т.е. като език за едносортна структура.  Това води до
% някои неудобства.  Едно от тях е това, че типът на изразите в програмата
% се определя от името на предиката.  Например предикатът = е равенство
% между термове, следователно стойностите на изразите от двете страни на =
% са термове.  Аритметичният предикат за равенство е #=.  При него
% стойностите на изразите от двете страни на равенството са цели числа.
% Примери:

%% ?- 1 + 2 = K.
%% K = 1+2.

%% ?- 1 + 2 #= K.
%% K = 3.

%% ?- 1 + K #= 10.
%% K = 9.

%% ?- 1 + 3*K #= 10.
%% K = 3.

%% ?- 1 + 2*K #= 10.
%% false.

% Ето някои от предикатите в библиотеката за целочислена аритметика:

% X #= Y       X е равно на Y
% X #\= Y      X е различно от Y
% X #> Y       X е по-голямо от Y
% X #< Y       X е по-малко от Y
% X #>= Y      X е по-голямо или равно от Y
% X #=< Y      X е по-малко или равно от Y
% X #<= Y      грешка

% Да дефинираме предикат за дължина на списък.  Иска ни се да направим това
% по следния начин:

% дълж(X, N) - N е дължината на X
%
% Условие: ....

дълж([], 0).
дълж([_|X], N+1) :- дълж(X,N).

% За съжаление не можем да направим това, защото пролог не е проектиран да
% работи с многосортни структури.  В следствие на това няма как да кажем на
% пролог, че вторият аргумент на предиката дълж е цяло число, а не израз.
% Затова предикатът дълж ще работи по следния начин:

%% ?- дълж([a,a,a,a], N).
%% N = 0+1+1+1+1.

% Когато използваме целочислена аритметика, трябва да спазваме следното
% правило: във фактите, както и отляво на :- не бива да се използват
% аритметични изрази.  По този начин пролог „разбира“ кои неща са числа и
% кои изрази.

% Ето как можем да дефинираме предикат за намиране на дължината на списък:

%% дължина([], N) :- N #= 0.
%% дължина([_|X], N) :- дължина(X, N-1).

% Пример:

% ?- дължина([a,a,a,a], N).
% N = 4.

% Да изведем условие за пълна коректност на предиката дължина.  Първата
% клауза в горната дефиниция свежда към предиката за ограничение #=, така
% че не може да доведе до зацикляне и затова не ни интересува.  Във втората
% клауза първият аргумент при рекурсивното извикване си намалява броя на
% елементите.  Следователно условието за пълна коректност е да бъде
% известно ограничение отгоре за броя на елементите на първия аргумент.
% Горният предикат обаче не може да се използва, ако дължината на списъка е
% известна, но самият списък е неизвестен.  Със съвсем малка подсказка този
% дефект може да се поправи:

% дължина(X, N) - N е дължината на X
%
% Условие: Известно е ограничение отгоре за N или за дължината на X

дължина([], N) :- N #= 0.
дължина([_|X], N) :- N #>= 0, дължина(X, N-1).

% Тук ако е известен вторият аргумент при рекурсивното извикване той ще се
% намали с единица.  Затова ако подскажем на пролог, че дължната на един
% списък не може да бъде отрицателно число, рекурсията ще бъде крайна.

% Да попитаме кой списък е с дължина 4:

%% ?- дължина(X, 4).
%% X = [_5544482, _5544648, _5544814, _5544980] ;
%% false.

% Да попитаме кои списъци са с дължина по-малка от 4:

%% ?- N #< 4, дължина(X, N).
%% N = 0,
%% X = [] ;
%% N = 1,
%% X = [_5548588] ;
%% N = 2,
%% X = [_5548588, _5550320] ;
%% N = 3,
%% X = [_5548588, _5550320, _5552566] ;
%% false.

% Вярно ли е, че [1,2,3,4] е с четна дължина?

%% ?- дължина([1,2,3,4], 2*K).
%% K = 2.

% Вярно ли е, че [1,2,3,4] е с нечетна дължина?

%% ?- дължина([1,2,3,4], 2*K+1).
%% false.

% nth(X, N, A) - А e N-тият елемент на списъка X
%
% Условие: Известно е ограничение отгоре за дължината на X или за N

nth([A|_], N, A) :- N #= 1.
nth([_|X], N1, A) :- N1 #>= 1, N1 #= N + 1, nth(X, N, A).

% Забележително е колко слабо условие за пълна коректност има този
% предикат.  Може да намерим N-тият елемент на списък, където N е
% неизвестно:

%% ?- nth([a,b,c], N, A).
%% N = 1, A = a ;
%% N = 2, A = b ;
%% N = 3, A = c ;
%% false.

% Можем да намерим третият елемент на списък, който е неизвестен:

%% ?- nth(X, 3, A).
%% X = [_89462, _89474, A|_89564]

% сума(X, N) - N е сумата от елементите на X
%
% Условие: Известно е ограничение отгоре за броя на елементите на X

сума([], N) :- N #= 0.
сума([K|X], N) :- N #= M + K, сума(X, M).

% Разбира се не е проблем да сметнем сумата на списък с известни елементи:

%% ?- сума([1,3,5],Сума).
%% Сума = 9.

% По-интересно обаче е това, че съгласно условието за пълна коректност може
% да прилагаме този предикат и към списъци, чиито елементи са неизвестни.
% Достатъчно ще бъде, ако дължината на списъка е известна:

%% ?- дължина(X, 3), сума(X, 5).
%% X = [_18300, _18306, _18312],
%% _18336 + _18300 #= 5,
%% _18312 + _18306 #= _18336

% факториел(N, F) - N! = F
%
% Условие: известно е ограничение отгоре за N

факториел(N, F) :- N #= 0, F #= 1.
факториел(N1, F1) :- N1 #> 0, N1 #= N + 1, F1 #= N1 * F, факториел(N, F).

% Да изведем условието за коректност на този предикат.  Първата клауза не
% ни интересува, защото свежда към предикати за ограничение.  Във втората
% клауза при рекурсивното извикване първият аргумент става с единица
% по-малък.  Но тъй като има условие този аргумент да бъде положително
% число, то това не може да става до безкрайност.  Така получаваме условие
% за коректност да бъде известно ограничение отгоре за първият аргумент.

% Трудно е да се разбере защо, но този предикат може да се използва и в
% обратна посока:

%% ?- факториел(F,120).
%% F = 5

% Може дори да попитаме кои числа имат факториел между 10^100 и 10^101:

%% ?- F #>= 10^100, F #=<10^101, факториел(N,F).
%% F = 119785716699698917960727837216890987364589381425464
%% 25857555362864628009582789845319680000000000000000,
%% N = 70 ;
%% false.

% Въпреки че не е ясно защо в този случай пролог работи, важното е, че
% имаме гаранция, че той не ни лъже.  Следователно 70 е единственото число,
% чийто факториел е между 10^100 и 10^101.

% Има важна разлика между „уравненията“ между термове и аритметичните
% уравнения.  При уравненията между термове има ефективен алгоритъм
% (алгоритъмът за унификация), който позволява на компютъра без много
% усилия да извлича решения на системата от уравнения.  При аритметичните
% уравнения такъв алгоритъм няма.  Ако кажем на компютъра някакво
% аритметично уравнения, той ще го запомни, ще види какви бързи следствия
% могат да се направят от него, но ако не му кажем изрично, компютърът няма
% сам да се опитва да намери конкретни решения на условията, които се знаят
% до момента.  Използваме предиката label([A1,A2,...An]), за да поискаме от
% компютъра да генерира конкретни стойности на A1,A2,...,An.  Примери:

%% ?- N #> 0, N #< 4.
%% N in 1..3.

%% ?- N #> 0, N #< 4, label([N]).
%% N = 1 ;
%% N = 2 ;
%% N = 3.

%% ?- A #> 0, B #> 0, A+B #<5.
%% A in 1..3,
%% A+B#=_80970,
%% B in 1..3,
%% _80970 in 2..4.

%% ?- A #> 0, B #> 0, A+B #<5, label([A,B]).
%% A = B, B = 1 ;
%% A = 1, B = 2 ;
%% A = 1, B = 3 ;
%% A = 2, B = 1 ;
%% A = B, B = 2 ;
%% A = 3, B = 1.

% Предикатът label може да се използва само тогава, когато е известна
% крайна област, в която компютърът може да търси решение:

%% ?- N #> 0, label([N]).
%% ERROR: Arguments are not sufficiently instantiated

% Когато търси решения, пролог не винаги ще пробва всички възможно елементи
% на крайната област.  Да попитаме например дали има цели числа X, Y и Z,
% които са между 1 и 10000 и са решение на диофантовото уравнение
% (X+1000)³ - 2*(Y+1000)³ = Z

%% ?- 1#=<X,1#=<Y,1#=<Z,X#=<10000,Y#=<10000,Z#=<10000,
%%    (X+1000)^3 - 2*(Y+1000)^3 #= Z, label([X,Y,Z]).
%% false.

% Да забележим, че за всяка променлива има 10000 възможни стойности.
% Следователно вариациите на (X,Y,Z) са 1000000000000.  Това е е повече,
% отколкото компютърът може да провери за разумно време.  Въпреки това
% пролог намира отговора сравнително бързо, защото се сеща, че не е нужно
% да проверява всички вариации.

% Два ненужни предиката, които позволяват по-кратък запис:

% A in P..Q е еквивалентно на A #>= P, А #=< Q.
% [A1,A2,A3] ins P..Q е еквивалентно на A1 in P..Q, A2 in P..Q, A3 in P..Q.

% Докато при предикатите #>= и #=< отляво и отдясно може да стоят
% аритметични изрази, от дясната страна на предикатите in и ins не може да
% се използват изрази, а само променливи или константи.  Например не може
% да пишем K in 10^2..10^3.


% Задача. Да се напише предикат ограничен_списък(N,X), който по дадено
% естествено число N генерира в X всички списъци, чиято дължина е по-малка
% или равна на N и чиито елементи са естествени числа, по-малки или равни
% на N.

% След като прочетем задачата, от него трябва да извлечем две неща:
% 1. логическа дефиниция за ограничен_списък и 2. условие, при което
% предикатът трябва да работи.  В случая това ни дава следната
% спецификация:

% ограничен_списък(N, X) - X е списък с дължина по-малка или равна на N,
%                          чиито елементи са естествени числа, по-малки или
%                          равни на N
%
% Условие: Известно е N.

% След като сме готови със спецификацията, можем да пристъпим и към самата
% дефиниция.  В случая тя се прави съвсем лесно с нещата, които вече знаем:

ограничен_списък(N, X) :- L #=< N, дължина(X, L), X ins 0..N, label(X).

%% ?- ограничен_списък(2,X).
%% X = [] ;
%% X = [0] ;
%% X = [1] ;
%% X = [2] ;
%% X = [0, 0] ;
%% X = [0, 1] ;
%% X = [0, 2] ;
%% X = [1, 0] ;
%% X = [1, 1] ;
%% X = [1, 2] ;
%% X = [2, 0] ;
%% X = [2, 1] ;
%% X = [2, 2] ;
%% false.

% Предикатът ins ни помогна да направим по-кратко решение, но всъщност може
% и без него:

ограничен_списък2(N, X) :- L #=< N, дължина(X, L), елементи_отдо(0, N, X),
			   label(X).

% елементи_отдо(N1, N2, X) :- елементите на X са цели числа между N1 и N2
%
% Условие: Известно е ограничение отгоре за дължината на X

% Най-естествено е да реализираме този предикат с квантор за всеобщност:

% елементи_отдо(N1, N2, X) :- ∀K(елемент(K,X) ⇒ N1 #=< K, K #=< N2)

% За съжаление кванторът за всеобщност все още няма пълноценна реализация
% на пролог.  Затова се налага да използваме рекурсивна дефиниция:

елементи_отдо(_, _, []).
елементи_отдо(N1, N2, [A|X]) :-
    A #>= N1, A #=< N2, елементи_отдо(N1, N2, X).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% БЕЗКРАЙНИ ГЕНЕРАТОРИ
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Безкрайните генератори нямат практически приложения, но на изпита по ЛП
% те често се използват за задачи.

% Методите за доказателство на коректност, които използвахме досега, не
% могат да се прилагат за безкрайни генератори.  За да се напише правилна
% дефиниция на безкраен генератор, има два подхода:
%
% 1. Да знаем как работи пролог.  Този подход по-традиционен, но има два
%    недостатъка: използваме пролог не като логически език и обръщаме
%    голямо внимание на особености на пролог, които най-вероятно няма да са
%    в сила при бъдещите езици за логическо програмиране.
%
% 2. Да сведем дефинирането на безкраен генератор към нещата, което вече
%    знаем как се правят.  За щастие това не е трудно.

% Най-напред запомняме наизуст следната дефиниция на генератор на естествените числа:

nat(N) :- N #= 0 ; nat(N-1).

%% ?- nat(N).
%% N = 0 ;
%% N = 1 ;
%% N = 2 ;
%% N = 3 ;
%% N = 4 ;
%% ...

% Няма да изследваме защо тази дефиниция работи, ами просто приемаме това
% като факт.  След като вече имаме тази дефиниция, чрез нея можем да
% дефинираме кой да е безкраен генератор по следния начин:

% безкраен_генератор(X) :- nat(N), краен_генератор(N, X).

% Тук краен_генератор(N, X) трябва да има следните свойства:
%
% 1. За всяко N има краен брой X, за които краен_генератор(N, X) е истина;
%
% 2. безкраен_генератор(X) е истина тогава и само тогава, когато за някое
%    естествено число N е истина краен_генератор(N, X).

% Пример 1.  Да се дефинира генератор на двойките [A,B] от естествени числа.

% Ето един неправилен, но често срещащ се на изпита начин:
%
% двойка естествени([A,B]) :- nat(A), nat(B).

% Горната дефиниция няма вида
%
%     безкраен_генератор(X) :- nat(N), краен_генератор(N, X).
%
% защото nat(B) не е краен генератор.  Ето един правилен начин:

двойка_естествени([A,B]) :- nat(N), A in 0..N, B in 0..N, label([A,B]).

% Горната дефиниция е правилна, защото
%
% 1. За всяко N има краен брой двойки [A,B], за които A in 0..N и B in 0..N
%
% 2. [A,B] е двойка от естествени числа тогава и само тогава, когато за
%    някое естествено число N е вярно A in 0..N и B in 0..N.

% Пример 2. Да се дефинира генератор на всички списъци от естествени числа.

списък_естествени(X) :- nat(N), L #=< N, дължина(X, L), X ins 0..N,
			label(X).

% Горната дефиниция е правилна, защото
%
% 1. За всяко N има краен брой X, които са списъци с дължина, по-малка или
%    равна на N и чиито елементи са от 0 до N
%
% 2. X е списък от естествени числа тогава и само тогава, когато съществува
%    такова естествено число N, че X е списък с дължина, по-малка или равна
%    на N и елементите му са от 0 до N.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% НЯКОИ ВЪЗМОЖНОСТИ НА ПРОЛОГ, КОИТО НИ ПОЗВОЛЯВАТ ДА ПИШЕМ КРАТКИ ПРОГРАМИ
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Тук ще разгледаме някои опасни възможности на пролог.  Те помагат да
% правим много кратки програми, но използването им е рисковано.  Ако
% използваме тези възможности неправилно, компютърът вместо да даде
% съобщение за грешка може да даде грешен отговор.


% ОТРИЦАНИЕ
% ---------

% Официален синтаксис: \+ p(X)
% Синтаксис, който тук ще бъде използвам: not(p(X))

% Отрицанието има следната особеност.  Да допуснем, че компютърът стига до
% not(p(X,Y)).  Нека тук X символизира всички неща, чиято стойност в този
% момент е известна, a Y – нещата, чиято стойност все още не е известна.
% Тогава смисълът на
%
%      not(p(X,Y))
%
% ще бъде
%
%     ¬∃Y p(X,Y)
%
% или, което е все едно:
%
%     ∀Y ¬p(X,Y)

% Да забележим, че неизвестните неща Y стават локални променливи, така че
% отрицанието не може да се използва като генератор, а само за проверка
% дали нещо вече известно няма определено свойство.

% Когато в целта на отрицанието се използват аритметични предикати, след
% изпълнението на целта не бива да остават променливи, които все още не са
% получили стойност.  За да подсигурим, че това няма да се случи, може в
% края на целта да използваме label.

% Примери:

% Тук питаме кои числа N между 0 и 10 не могат да се представят като сума
% на два квадрата на числа между 0 и 10:

%% ?- 0 #=< N, N #=< 10, label([N]),
%%    not((0 #=< A, A #=< 10, 0 #=< B, B #=< 10,
%%         N #= A^2+B^2, label([A,B]))).

% Тук питаме вярно ли е, че за всеки N, A и B от 0 до 10 числото N няма да
% бъде сума на квадратите на A и B:

% По-добре е обаче горният въпрос да бъде зададен по следния начин:

%% ?- not((0 #=< N, N #=< 10, 0 #=< A, A #=< 10, 0 #=< B, B #=< 10,
%%         N #= A^2+B^2, label([A,B,N]))).

% Тук питаме какви трябва да бъдат N, A и B, така че да бъдат числа от 0 до
% 10 и N да не бъде сума от квадратите на A и B:

%% ?- 0 #=< N, N #=< 10, 0 #=< A, A #=< 10, 0 #=< B, B #=< 10,
%%    N #\= A^2+B^2, label([A,B,N]).

% Да дефинираме на един ред предикат, който проверява дали дадено число е
% просто.

% просто(P) - P е просто число
%
% Условие: известно е P

просто(P) :- P #>= 2, not((K #>= 2, K #< P, P #= K * M, label([K, M]))).

% УНИВЕРСАЛЕН КВАНТОР С ИМПЛИКАЦИЯ
% --------------------------------

% Синтаксис: forall(p(X), q(X)).

% Да допуснем, че компютърът стига до forall(p(X,Y), q(X,Y,Z)).  Нека тук X
% символизира всички неща, чиято стойност в този момент е известна, а Y са
% нещата в p(X,Y), чиято стойност все още не е известна.  Нека Z са неща,
% чиято стойност не става известна дори след изпълнението на p(X,Y).
% Тогава смисълът на
%
%      forall(p(X,Y), q(X,Y,Z))
%
% ще бъде
%
%      ∀Y(p(X,Y) ⇒ ∃Z q(X,Y,Z))

% Да забележим, че също както при отрицанието, и тук неизвестните неща
% получават квантори.  Затова предикатът forall не може да се използва като
% генератор, а само за проверка дали нещо, вече известно, има определени
% свойства.

% След изпълнението на p(X,Y) стойността на Y трябва да стане напълно
% известна.  След изпълнението на q(X,Y,Z) всички аритметични променливи от
% Z трябва да получат стойност.  За да подсигурим последното, може в края
% на q(X,Y,Z) да използваме label.

% Примери:

% Вярно ли е, че всички елементи на [2,4,6,-7] са положителни?
%% ?- forall(елемент(A, [2,4,6,-7]), A #> 0).
%% false.

% Вярно ли е, че всички елементи на [2,4,6,-8] са четни?
%% ?- forall(елемент(A, [2,4,6,-8]), A #= 2*K).
%% true.

% Да забележим, че в момента, в който пролог изпълнява A #= 2*K,
% променливата A вече има конкретна стойност и значи K също ще получи
% конкретна стойност.  Затова е изпълнено изискването на forall да не се
% оставят аритметични променливи с неуточнена стойност.  Но ако не сме
% сигурни, може да се „подсигурим“ по следния начин:

%% ?- forall(елемент(A, [2,4,6,-8]), (A #= 2*K, label([K]))).

% Пример 1.  Да се дефинира предикат r(X,Y), който по дадени списъци X и Y
% проверява дали всеки елемент на X, който е четно число, е елемент на Y.

% r(X, Y) - всеки елемент на X, който е четно число е елемент на Y
%
% Условие: X и Y са известни списъци

r(X, Y) :- forall( (елемент(A, X), A #= 2*B, label([B])),
		   елемент(A, Y) ).

% Ще дефинираме предикат за „подмножество“ по два начина: с импликация и с
% рекурсия.  Най-напред с импликация.

% подмножество1(X, Y) - елементите на X са елементи на Y
%
% Условие: X и Y са известни списъци
подмножество1(X, Y) :- forall( елемент(A, X), елемент(A, Y) ).

% подмножество2(X, Y) - елементите на X са елементи на Y
%
% Условие: известно е ограничение отгоре за броя на елементите на X и на Y

подмножество2([], _).
подмножество2([A|X], Y) :- елемент(A, Y), подмножество2(X, Y).

% Да забележим, че първата дефиниция е по-кратка, но има много
% по-ограничително условие: може да се използва само за проверка.  Втората
% дефиниция може да бъде прилагана и към списъци, чиито елементи все още не
% са известни.

%% ?- подмножество1([1,3],[1,2,3]).
%% true.

%% ?- подмножество1([1,7],[1,2,3]).
%% false.

% Кои списъци с дължина по-малка или равна на 2 са подмножества на [1,2,3]:

%% ?- N #=< 2, дължина(X, N), подмножество2(X, [1,2,3]).
%% N = 0, X = [] ;
%% N = 1, X = [1] ;
%% N = 1, X = [2] ;
%% N = 1, X = [3] ;
%% N = 2, X = [1, 1] ;
%% N = 2, X = [1, 2] ;
%% N = 2, X = [1, 3] ;
%% N = 2, X = [2, 1] ;
%% N = 2, X = [2, 2] ;
%% N = 2, X = [2, 3] ;
%% N = 2, X = [3, 1] ;
%% N = 2, X = [3, 2] ;
%% N = 2, X = [3, 3] ;
%% false.

% Ако вместо подмножество2 използваме подмножество1 компютърът ще ни
% излъже, че всички списъци с дължина 0, 1 или 2 са подмножества на
% [1,2,3], защото не е спазено по-ограничителното условие за коректност:

%% ?- N #=< 2, дължина(X, N), подмножество1(X, [1,2,3]).
%% N = 0, X = [] ;
%% N = 1, X = [_] ;
%% N = 2, X = [_, _] ;
%% false.


% СПИСЪК ОТ ВСИЧКИ РЕШЕНИЯ
% ------------------------

% findall(A, P, X) е приблизително същото като X = {A: P}
%                    т.е. X става списък от всички A, за които P е вярно.

% Изискванията за използване на findall подобни на тези на not и forall.
% На всички неща в P, които не се срещат в A и при извикването на findall
% все още не са получили стойност, ще бъде сложен квантор ∃.  След
% изпълнението на P всички променливи в P и A (не само аритметичните)
% трябва да са получили конкретни стойности.

% Пример:

% X е списък от четните елементи на [1,3,4,2,9,22]:
%% ?- findall(A,
%%            (елемент(A,[1,3,4,2,9,22]), A #= 2*K),
%%            X).
%% X = [4, 2, 22].

% Да забележим, че горе при изпълнението на A #= 2*K променливата A вече
% има конкретна стойност и значи K също ще получи конкретна стойност.  По
% този начин всички променливи получават стойност, което е изискване на
% findall. Ако не сме сигурни за този тип неща, е по-добре да се подсигурим
% с label:

%% ?- findall(A,
%%            (елемент(A,[1,3,4,2,9,22]), A #= 2*K, label([K])),
%%            X).


% Да получим списък от простите числа между 0 и 1000:

%% ?- findall(P, (P in 0..1000, label([P]), просто(P)), X).
%% X = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,
%% 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139,
%% 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227,
%% 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311,
%% 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401,
%% 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491,
%% 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,
%% 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683,
%% 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,
%% 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,
%% 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997].


% Задача.  Да се дефинира предикат ppp(X), който по даден списък от списъци
% X проверява дали сумата на елементите на четна позиция във всеки елемент
% на X, съдържащ просто число, e предпоследен елемент на елемент на X

% Най-напред от условието на задачата извличаме спецификацията на предиката:

% ppp(X) - сумата на елементите на четна позиция във всеки елемент на X,
%          съдържащ просто число, e предпоследен елемент на елемент на X
%
% Условие: X е известен списък

% Най-напред нека да изкажем условието на задачата по по-логически начин:

% Да се дефинира предикат ppp(X), който по даден списък от списъци
% X проверява дали е изпълнено следното свойство:
%
% за всяко Y ако
%      Y∈X и
%      ∃A(A∈Y и просто(А)) и
%      S е сумата на елементите на четна позиция в Y,
% то съществува Z, такова че
%      Z∈X и
%      S е предпоследен елемент на Z

ppp(X) :-
    forall( ( елемент(Y, X),
	      елемент(A, Y), просто(A),
	      findall(B, (nth(Y, N, B), N #= 2*_), Y2), сума(Y2, S) ),
	    ( елемент(Z, X),
	      конкат(_, [S, _], Z) ) ).

% Задача.  Да се дефинира предикат pppp(X), който по даден списък X от
% списъци от числа проверява дали всеки предпоследен елемент на елемент на
% четна позиция е просто число.

% Отново най-напред от условието на задачата извличаме спецификацията:

% pppp(X) - всеки предпоследен елемент на елемент на четна позиция в X е
%           просто число
%
% Условие: Известен е X.

pppp(X) :-
    % Тук X е известно, а за всички останали променливи има локални
    % квантори.
    forall(( % ∀K ∀A                            % за всеки K и A
             nth(X, 2*_K, A),                   % ако A е 2.К-тия елем. на X
             съединение(_, [Предпоследен,_], A) % и Предпоследен е предпо-
           ),                                   %   следният елем. на A
           просто(Предпоследен)).               % то Предпоследен e просто


% СОРТИРОВКА

% В книгите и Интернет може да се намерят различни начини за сортировка на
% пролог.  Тези начини общо взето са същите, които може да се използват и
% при програмиране с функционален език.  Затова тук няма да ги показваме.
% Вместо това ще видим един начин за сортировка, който е неефективен и
% затова на практика неприложим, но за сметка на това е много кратък.
% Последното прави този начин за сортировка идеален за изпита.

% Започваме с математическата дефиниция на X

% сорт(X, Y) - Y е пермутация на X, която е сортирана
%
% Условие: X е известен числов списък.

% Един списък е сортиран, ако за всеки два негови съседни елементи A и B е
% вярно A ≦ B.  На пролог можем да кажем, че A и B са съседни елементи на
% даден списък, например [1,2,3,4,5,6], по следния начин:

%% ?- конкат(_, [A,B|_], [1,2,3,4,5,6]).
%% A = 1, B = 2 ;
%% A = 2, B = 3 ;
%% A = 3, B = 4 ;
%% A = 4, B = 5 ;
%% A = 5, B = 6 ;
%% false.

% Сега вече сме готови да преведем директно на пролог математическата
% дефиниция на sort:

сорт(X, Y) :- пермутация(X, Y), forall(конкат(_, [A,B|_], Y), A #=< B).

%% ?- сорт([1,6,2,3,8,4], X).
%% X = [1,2,3,4,6,8]


% Първа задача от писмения изпит по ЛП, януари 2023
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Списък от естествени числа [a_1, a_2,..., a_3n] ще наричаме
% специфичен, ако за всяко естествено число k ∈ {1,...,n} е изпълнено:
%
%        ⎧ a_(a_k + 6),   ако 1 ≦ a_k + 6 ≦ 3n и 1 ≦ a_k ≦ k
% a_3k = ⎨
%        ⎩ 3a_(3n−k) + 1, иначе
%
% Да се дефинира предикат s(X), който при преудовлетворяване генерира в X
% всички специфични списъци.

% Най-напред ще направим кратко решение „като за изпит“.  След това ще
% видим едно незначително по-дълго, но много по-ефективно решение.

% s е безкраен генератор, значи дефиницията му ще има вида

% Краткото решение има следната структура:
%
% s1(X) :- генерираме_произволен_списък(X),
%          проверяваме_че_е_специфичен(X).

s1(X) :- nat(N), Дълж #=< N, дължина(X, Дълж), X ins 0..N, label(X),
	 специфичен(X).

% специфичен(X) - X е специфичен
%
% Условие: X е известен списък

специфичен(X) :-
    дължина(X, 3*N),
    forall( ( K in 1..N, label([K]) ),
	    ( nth(X, K, Ak),
	      nth(X, 3*K, A3k),
	      (  1 #=< Ak+6, Ak+6 #=< 3*N, 1 #=< Ak, Ak #=< K
	      -> nth(X, Ak+6, A3k)
	      ;  A3k #= 3*A3nk+1, nth(X, 3*N-K, A3nk) ) ) ).

% Проверка:

%% ?- s1(X).
%% X = [] ;
%% X = [] ;
%% X = [] ;
%% X = [] ;
%% X = [0, 0, 1] ;
%% X = [1, 0, 1] ;
%% X = [2, 0, 1] ;
%% X = [3, 0, 1] ;
%% X = [] ;
%% X = [0, 0, 1] ;
%% X = [0, 1, 4] ;
%% X = [1, 0, 1] ;
%% ...

% При търсене на 6-елементни специфични списъци се усеща леко забавяне:

%% ?- X=[_,_,_,_,_,_], s1(X).
%% X = [0, 0, 1, 0, 0, 1] ;
%% X = [0, 0, 1, 1, 0, 4] ;
%% X = [0, 0, 4, 0, 1, 1] ;
%% X = [0, 0, 4, 1, 1, 4] ;
%% ...

% При търсене на 9-елементни специфични списъци компютърът все още може да
% намери отговори, но доста бавно:

%% ?- X=[_,_,_,_,_,_,_,_,_], s1(X).
%% X = [0, 0, 1, 0, 0, 1, 0, 0, 0] ;
%% X = [0, 0, 1, 0, 0, 4, 1, 0, 1] ;
%% X = [0, 0, 1, 0, 0, 7, 2, 0, 2] ;
%% ...

% Горният предикат не е в състояние да намери 12-елементни специфични
% списъци за разумно време.

% Причината за бавната работа на предиката е следната: има твърде много
% произволни списъци от естествени числа и само една малка част от тях са
% специфични.

% За да избегнем (а по-точно отложим) този комбинаторен взрив, ще се
% възползваме от възможността на пролог да работи с неизвестни числа.
% Преди още да генерираме конкретни стойности на елементите на списъка, ще
% кажем на компютъра формулите, които са верни за един специфичен списък.
% По този начин ще трябва да се генерират много по-малко списъци.

% С други думи, горното решение, което има следния вид

% s(X) :- nat(N),
%         дължината на X е ≦ N, елементите на X са 0..N,
%         label(X),
%         специфичен(X).

% ще преобразуваме в ето този вид:

% s(X) :- nat(N),
%         дължината на X е ≦ N, елементите на X са 0..N,
%         специфичен(X),
%         label(X).

% Ще се наложи обаче да дадем друга дефиниция на предиката специфичен.
% Горната дефиниция не е подходяща, защото по две причини не може да се
% използва тогава, когато елементите на X са неизвестни:
%
% 1. forall може да се използва само за проверка дали неща, които вече са
%    известни имат дадено свойство.  В случая X трябва да бъде известен
%    списък.
%
% 2. „Функционалният“ условен оператор ( условие -> ако_да ; ако_не ) също
%    работи само ако в условието вече са известни всички неща.  Ако обаче
%    елементите на X са неизвестни, то и условието няма да бъде ясно дали е
%    истина или лъжа.
%
% Тези проблеми се решават по следния начин:
%
% 1. Вместо forall ще използваме рекурсивна дефиниция.
%
% 2. Вместо ( A -> B ; C ) ще използваме ((A, B) ; (¬A, C)).

s2(X) :- nat(N), Дълж #=< N, дължина(X, Дълж), X ins 0..N,
	 специфичен2(X), label(X).

% специфичен2(X) - X е специфичен
%
% Условие: X е списък с известна дължина

специфичен2(X) :-
    дължина(X, 3*N),
    частично_специфичен(X, N).

% частично_специфичен(X, M) - Нека 3n е дължината на X.  Тогава за всяко
%                             естествено число k ∈ {1,...,M} е изпълнено:
%
%        ⎧ a_(a_k + 6),   ако 1 ≦ a_k + 6 ≦ 3n и 1 ≦ a_k ≦ k
% a_3k = ⎨
%        ⎩ 3a_(3n−k) + 1, иначе

частично_специфичен(_, K) :- K #= 0.
частично_специфичен(X, K) :-
    K #> 0,
    дължина(X, 3*N),
    nth(X, K, Ak),
    nth(X, 3*K, A3k),
    ( 1 #=< Ak+6, Ak+6 #=< 3*N, 1 #=< Ak, Ak #=< K,
      nth(X, Ak+6, A3k)
    ; ( 1 #> Ak+6 #\/ Ak+6 #> 3*N #\/ 1 #> Ak #\/ Ak #> K ),
      A3k #= 3*A3nk+1, nth(X, 3*N-K, A3nk) ),
    специфичен(X, K-1).

% Благодарение на това, че в дефиницията на s2 и помощните му предикати
% работим не с напълно генерирани списъци, а със списъци с неизвестни
% елементи, то s2 работи значително по-бързо от s1.  Предикатът s1 не е в
% състояние да генерира списъци с двуцифрена дължина.  Предикатът s2 е в
% състояние да генерира списъци дори с трицифрена дължина.

%%%%%%%%%%%%%%%%%%%%
% ГРАФИ
%%%%%%%%%%%%%%%%%%%%

% Въпреки че пролог не е обектноориентиран език, има начин да програмираме
% така, че да имитираме използването на абстрактен клас с наследници.
% Точно така искаме да постъпим, когато работим с графи, защото не
% съществува оптимална структура данни, представяща графите.  За някои
% задачи едно представяне е по-ефективно, за други друго.  Всички тези
% представяния ще бъдат различни наследници на абстрактния клас „граф“.  По
% този начин ако направим някой предикат да използва абстрактния клас
% „граф“, то този предикат ще бъде използваем независимо как представяме
% графа в паметта на компютъра.

% В „интерфейса“ на абстрактния клас „граф“ ще имаме само следните два
% предиката:

% връх(G, v) - v е връх в графа G
% ребро(G, u, v) - (u,v) е ребро в графа G

% Тъй като всеки „наследник“ на класа „граф“ ще има свои собствени
% дефиниции на връх и ребро, то пролог „ще се притесни“ и ще ни дава много
% предупреждения.  Въпреки предупрежденията, програмата е вярна, но
% най-добре да успокоим пролог със следните две подсказки:

:- discontiguous връх/2.
:- discontiguous ребро/3.

% Да дефинираме „наследник“ на този абстрактен клас, при който графът се
% представя по обичайния математически начин – като двойка (VV, EE), където
% VV е списък от върховете, a ЕЕ списък от ребрата.

връх((VV,_EE), V) :- елемент(V, VV).
ребро((_VV,EE), U, V) :- елемент((U,V), EE).

% С това приключи дефиницията на първия наследник на класа „граф“.

% Много често в задачите на изпита по ЛП графите се представят посредством
% списък от двойки [u,v] – по една такава двойка за всяко ребро (u,v).
% Разбира се такова представяне може да се използва само за графи без
% изолирани върхове, защото по същество помним само ребрата, а изолираните
% върхове нямат ребра.

% При такова представяне на графа, предикатите връх и ребро може да се
% дефинират така:

връх(G, U) :- елемент([U,_], G) ; елемент([_,U], G).
ребро(G, U, V) :- елемент([U,V], G).

% Вече имаме и втори наследник на класа „граф“.  Важно е, че тези две
% представяния не се припокриват.  При първото графът е списък, при второто
% е наредена двойка.  Наредените двойки (VV,EE) не са списъци, нито
% списъците са наредени двойки, така че няма да има „интерференция“ между
% двете дефиниция на връх и ребро.

% Да дефинираме още едно представяне на графи, което често се оказва
% най-ефективно.  Графът G ще представяме посредством такъв списък, че за
% всеки връх U в списъка има единствен елемент от вида [U,V1,V2,...,Vn] и в
% графа има ребро (U,V) тогава и само тогава, когато V=Vi за някое i.

% Тъй като при предното представяне графът също бе списък, тук вместо
% списък X ще използваме терм от вида f(X).  Може да считаме, че f е името
% на класа наследник на класа „граф“.  Ако това бе по-реалистичен пример,
% то вместо f трябваше да използваме някакво по-разбираемо име.

връх(f(X), U) :- елемент([U|_], X).
ребро(f(X), U, V) :- елемент([U|VV], X), елемент(V, VV).

% Ще дефинираме още два „класа“, g1 и g2.  Всеки от тях отговаря на
% единствен граф, чиито върхове и ребра се задават посредством факти на
% пролог:

% Конкретни графи G1 и G2

връх(g1, a).  връх(g1, b).  връх(g1, c).  връх(g1, d).
връх(g1, e).  връх(g1, f).  връх(g1, g).  връх(g1, h).

ребро(g1, a, b).  ребро(g1, a, c).  ребро(g1, b, d).
ребро(g1, c, d).  ребро(g1, c, e).  ребро(g1, d, f).
ребро(g1, e, f).  ребро(g1, e, g).  ребро(g1, f, h).
ребро(g1, g, h).

връх(g2, a).  връх(g2, b).  връх(g2, c).  връх(g2, d).
връх(g2, e).  връх(g2, f).  връх(g2, g).  връх(g2, h).

ребро(g2, a, a).  ребро(g2, a, e).  ребро(g2, a, b).
ребро(g2, b, d).  ребро(g2, c, b).  ребро(g2, d, c).
ребро(g2, d, e).  ребро(g2, e, f).  ребро(g2, f, d).
ребро(g2, g, h).  ребро(g2, g, e).  ребро(g2, h, g).
ребро(g2, h, f).

% Често път се дефинира като редица от вида връх-ребро-връх-ребро-....  На
% други места път се дефинира просто като редица от ребра.

% Тук ще считаме, че път е такава непразна редица от върхове, че между
% всеки два съседни има ребро

% път(G, U, V, X) - X е път в G от връх U до връх V
%
% Условие: G е краен граф и (G е ацикличен или е известно ограничение
%          отгоре за дължината на пътя X)

път(G, V, V, [V]) :- връх(G, V).
път(G, V1, U, [V1,V2|X]) :- ребро(G, V1, V2), път(G, V2, U, [V2|X]).

% Тук поради извикването на връх(G,..) и ребро(G,..,..) се налага G да бъде
% краен граф (иначе може да генерираме безброй много върхове и ребра).
% Разбира се с представянията, които имаме до момента, може да се дефинират
% само крайни графи.  В момента обаче ние работим не с тези представяния, а
% с абстрактния клас „граф“, а той може да има наследник, позволяващ
% безкрайни графи.

% Ако графът е ацикличен, то рекурсията е крайна благодарение на втория
% аргумент.  Ако е известно ограничение отгоре за дължината на пътя, тогава
% помага четвъртият аргумент.

% Примери:

%% ?- път(g1, a, f, X).
%% X = [a, b, d, f] ;
%% X = [a, c, d, f] ;
%% X = [a, c, e, f] ;
%% false.

%% ?- път(g2, a, f, X).
%% ERROR: Stack limit (1.0Gb) exceeded

%% ?- N #=< 5, дължина(X, N), път(g2, a, f, X).
%% N = 3, X = [a, e, f] ;
%% N = 4, X = [a, a, e, f] ;
%% N = 5, X = [a, a, a, e, f] ;
%% N = 5, X = [a, b, d, e, f] ;
%% false.
